<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<article>
  <title>Pia - Annotations for PHP</title>
  <section>
    <title>Introduction</title>
    <para>Pia is a small API to emulate Java-like annotations in PHP.</para>
    <para>Many PHP projects already use some sort of custom-built annotation mechanism, one of the most prominent examples being PHPUnit. Pia takes those approaches one step further by implementing a full-fledged context-free grammar.</para>
  </section>
  <section>
    <title>Basics</title>
    <para>Let&apos;s start with an example:</para>
    <para><programlisting>/**
  * @my.awesome.annotation(
  *   foo=&quot; b a r &quot;, 
  *   bar=3.1
  *   baz=[&quot;lorem&quot;, &quot;ipsum&quot;]
  * )
  */
  function foo() {
      // code
  }</programlisting></para>
    <para>A pia annotation can be named arbitrarily, there are no restrictions for the name except that it cannot contain whitespace. Every annotation can define named parameters. If it has no parameters the parenthesis can be omitted. Parameter values can be strings, integers, floats, booleans and arrays (including associative arrays) as well as the <code>null</code> literal.</para>
    <para>Let&apos;s look at another example:</para>
    <para><programlisting>/**
  * @foobar(arr=[
  *     &quot;a&quot;:true, 
  *     &quot;b&quot;:null, 
  *     &quot;c&quot;:false, 
  *     &quot;d:&quot;:3.14159265, 
  *     &quot;e&quot;:[1, 2, 3], 
  *     &quot;f&quot;:[&quot;a&quot;:[1, 2], b:[true, false]]
  * ])
  */</programlisting></para>
    <para>As you can see the array notation is borrowed from JSON and  arrays can be nested arbitrarily. </para>
    <para>The asterisk is ignored by the parser, just like whitespace. That means you can do stuff like this:</para>
    <para><programlisting>/*************
 * @foo(x=1, *
 *      y=2, *
 *      z=3) *
 *************/</programlisting></para>
    <para>The parser also ignores anything before and after an annotation. However once an <code>@</code> is encountered it expects a well-formed annotation. Therefore the following can be parsed without problems:</para>
    <para><programlisting>/**
  * lorem ipsum
  * @annotation lorem
  * ipsum @another.annotation lorem
  * ipsum @and.another(foo=&quot;bar&quot;, bar=42) lorem
  * ipsum
  */</programlisting></para>
  </section>
  <section>
    <title>The API</title>
    <para>The Pia API can be used to retrieve (i.e. parse) annotations on the fly at runtime. In order to retrieve the phpdoc which contains the annotations it is necessary to use the reflection API. <programlisting>use pia\Registry;

$reflect = new \ReflectionClass(&apos;MyAnnotatedClass&apos;);
$annotations = Registry::getAnnotations($reflect);</programlisting>Because reflection is generally slow it is not recommended to use the API in this manner if performance matters (note that the annotations will be cached in memory by the registry therefore repeating the call won&apos;t reparse the phpdoc comment).</para>
    <para>Fortunately Pia provides a simple alternative that&apos;s pretty much  as fast as possible in PHP userland. Because annotations are compile-time metadata we can simply preprocess the annotated codebase and compile the annotations into an array. </para>
    <para>For this purpose Pia comes with a small CLI script (<emphasis role="italic">bin/pia.php</emphasis>) that you can use to process your source code. The script expects two parameters, the first one being either a file or a directory while the second parameter specifies the output file. The code generated by the script looks like this:</para>
    <para><programlisting>&lt;?php
// generated by Pia
// 2010-06-17T11:36:07+02:00
return array(
&apos;Foo&apos; =&gt; array(
new \pia\Annotation(&apos;foobar&apos;, array (
  &apos;foo&apos; =&gt; &apos;bar&apos;,
  &apos;bar&apos; =&gt; &apos;baz&apos;,
)),
),
);</programlisting></para>
    <para>You don&apos;t need to concern yourself with  this detail though. You only need to load this file with the Registry using its load method:</para>
    <para><programlisting>use pia\Registry;
$reg = new Registry();
$reg-&gt;load(&apos;annotations.php&apos;);</programlisting></para>
    <para>Now if you want to lookup the annotations of a specific element without using the reflection API you need to know how Pia maps PHP code elements to unique array keys. The rules are very simple: the key of a class is simply it&apos;s name, the key of a method is <code>&lt;class name&gt;::&lt;method name&gt;</code> and the key of a property is <code>&lt;class name&gt;::$&lt;property name&gt;</code>. The key for a function is its name prefixed by the hash symbol (#).</para>
    <para>Therefore if we define the following class:</para>
    <para><programlisting>/**
 * @foobar(foo=&quot;bar&quot;, bar=&quot;baz&quot;)
 */
class Foo {
    /**
     * @another.annotation
     */
    private $bar;

    /**
     * @and.another.one
     */ 
    function baz() {
        // code
    }
}</programlisting></para>
    <para>You can lookup the annotations the following way:</para>
    <para><programlisting>use pia\Registry;
$reg = new Registry;
$reg-&gt;load(&apos;annotations.php&apos;);

$reg-&gt;hasAnnotations(&apos;Foo&apos;);
$reg-&gt;hasAnnotations(&apos;Foo::baz&apos;);
$reg-&gt;hasAnnotations(&apos;Foo::$bar&apos;);</programlisting></para>
    <section>
      <title>Annotation lookup</title>
      <para>It is often desired to retrieve elements with a specific annotation therefore the Pia registry provides a function called <code>find</code> for this purpose.</para>
      <para>Example:</para>
      <para><programlisting>use pia\Registry;
$reg = new Registry;
$reg-&gt;load(&apos;annotations.php&apos;);
$elements = $reg-&gt;find(&apos;my.cool.annotation&apos;);</programlisting></para>
      <para>Because the registry internally stores the annotations in an array indexed by a key based on the annotated element name (see above) a linear search is required to extract elements with a specific annotation. To optimize this the registry contains a setting called <code>reverseIndexEnabled</code> which, if set to <code>true</code>, causes the registry to additionally build a reverse index of the annotations, i.e. it puts all annotated elements into an array indexed by annotation name thus enabling constant time lookup. </para>
      <para>Example usage:</para>
      <para><programlisting>use pia\Registry;
$reg = new Registry;
// enable reverse index so we can
// find elements with a specific annotation in
// constant time
$reg-&gt;setReverseIndexEnabled(true);
$reg-&gt;load(&apos;annotations.php&apos;);
$elements = $reg-&gt;find(&apos;my.cool.annotation&apos;);</programlisting></para>
      <para>The <code>find</code> function returns an array of appropriate reflection instances for each matching element.</para>
    </section>
  </section>
</article>
