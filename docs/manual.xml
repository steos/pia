<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<article>
  <title>Pia - Annotations for PHP</title>
  <section>
    <title>Introduction</title>
    <para>Pia is a small API to emulate Java-like annotations in PHP.</para>
    <para>Many PHP projects already use some sort of custom-built annotation mechanism, one of the most prominent examples being PHPUnit. Pia takes those approaches one step further by implementing a full-fledged context-free grammar.</para>
  </section>
  <section>
    <title>Basics</title>
    <para>Let&apos;s start with an example:</para>
    <para><programlisting>/**
  * @my.awesome.annotation(
  *   foo=&quot; b a r &quot;, 
  *   bar=3.1
  *   baz=[&quot;lorem&quot;, &quot;ipsum&quot;]
  * )
  */
  function foo() {
      // code
  }</programlisting></para>
    <para>A pia annotation can be named arbitrarily, there are no restrictions for the name except that it cannot contain whitespace. Every annotation can define named parameters. If it has no parameters the parenthesis can be omitted. Parameter values can be strings, integers, floats, booleans and arrays (including associative arrays).</para>
    <para>Let&apos;s look at another example:</para>
    <para><programlisting>/**
  * @foobar(arr=[
  *     &quot;a&quot;:true, 
  *     &quot;b&quot;:null, 
  *     &quot;c&quot;:false, 
  *     &quot;d:&quot;:3.14159265, 
  *     &quot;e&quot;:[1, 2, 3], 
  *     &quot;f&quot;:[&quot;a&quot;:[1, 2], b:[true, false]]
  * ])
  */</programlisting></para>
    <para>The array notation is borrowed from JSON and that you can nest them as much as you like. The asterisk is ignored by the parser, just like whitespace. That means you can do stuff like this:</para>
    <para><programlisting>/*************
 * @foo(x=1, *
 *      y=2, *
 *      z=3) *
 *************/</programlisting></para>
    <para>The parser also ignores anything before and after an annotation. However once an @ is encountered it expects a well-formed annotation. Therefore the following can be parsed without problems:</para>
    <para><programlisting>/**
  * lorem ipsum
  * @annotation lorem
  * ipsum @another.annotation lorem
  * ipsum @and.another(foo=&quot;bar&quot;, bar=42) lorem
  * ipsum
  */</programlisting></para>
  </section>
  <section>
    <title>The API</title>
    <para>The Pia API can be used to retrieve (i.e. parse) annotations on the fly at runtime. In order to retrieve the phpdoc which contains the annotations it is necessary to use the reflection API. <programlisting>use pia\Registry;

$reflect = new \ReflectionClass(&apos;MyAnnotatedClass&apos;);
$annotations = Registry::getAnnotations($reflect);</programlisting>Because this  is slow it is not recommended to use it if performance matters (note that the annotations will be cached in memory by the registry therefore repeating the call won&apos;t reparse the phpdoc comment).</para>
    <para>Fortunately Pia provides a simple alternative that&apos;s as fast as you can get with PHP. Because annotations are compile-time metadata we can simply preprocess the annotated codebase and compile the annotations into an array. </para>
    <para>For this purpose Pia comes with a small CLI script that you can use to process your source code. The script expects two parameters, the first one being either a file or a directory while the second parameter specifies the output file. The code generated by the script looks like this:</para>
    <para><programlisting>&lt;?php
// generated by Pia
// 2010-06-17T11:36:07+02:00
return array(
&apos;Foo&apos; =&gt; array(
new \pia\Annotation(&apos;foobar&apos;, array (
  &apos;foo&apos; =&gt; &apos;bar&apos;,
  &apos;bar&apos; =&gt; &apos;baz&apos;,
)),
),
);</programlisting></para>
    <para>You don&apos;t need to concern yourself with  this detail though. You only need to load this file with the Registry using its load method:</para>
    <para><programlisting>use pia\Registry;
$reg = new Registry();
$reg-&gt;load(&apos;annotations.php&apos;);</programlisting></para>
    <para>Now if you want to lookup the annotations of a specific element without using the reflection API you need to know how Pia maps PHP code elements to unique array keys. The rules are very simple: the key of a class is simply it&apos;s name, the key of a method is <code>&lt;class name&gt;::&lt;method name&gt;</code> and the key of a property is <code>&lt;class name&gt;::$&lt;property name&gt;</code>. The key for a function is its name prefixed by the hash symbol (#).</para>
    <para>Therefore if we define the following class:</para>
    <para><programlisting>/**
 * @foobar(foo=&quot;bar&quot;, bar=&quot;baz&quot;)
 */
class Foo {
    /**
     * @another.annotation
     */
    private $bar;

    /**
     * @and.another.one
     */ 
    function baz() {
        // code
    }
}</programlisting></para>
    <para>You can lookup the annotations the following way:</para>
    <para><programlisting>use pia\Registry;
$reg = new Registry;
$reg-&gt;load(&apos;annotations.php&apos;);

$reg-&gt;hasAnnotations(&apos;Foo&apos;);
$reg-&gt;hasAnnotations(&apos;Foo::baz&apos;);
$reg-&gt;hasAnnotations(&apos;Foo::$bar&apos;);</programlisting></para>
  </section>
</article>
