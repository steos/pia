Pia - Annotations for PHP
=========================

== Introduction

Pia is a small API to emulate Java-like annotations in PHP.
Many PHP project already use some sort of custom-built annotation mechanism, 
one of the most prominent examples being PHPUnit. Pia takes those approaches
one step further by implementing a full-fledged context-free grammar.

== Basics

Let's start with an example:

[source,php]
------------
<?php
/**
  * @my.awesome.annotation(
  *   foo=" b a r ", 
  *   bar=3.1
  *   baz=["lorem", "ipsum"]
  * )
  */
  function foo() {
      // code
  }
------------
  
A pia annotation can be named arbitrarily, there are no restrictions for the 
name except that it cannot contain whitespace. Every annotation can define named 
parameters. If it has no parameters the parenthesis can be omitted. Parameter 
values can be strings, integers, floats, booleans and arrays (including 
associative arrays) as well as the null literal. Let's look at another 
example:

Let's look at another example:

[source,php]
------------
<?php
/**
  * @foobar(arr=[
  *     "a":true, 
  *     "b":null, 
  *     "c":false, 
  *     "d:":3.14159265, 
  *     "e":[1, 2, 3], 
  *     "f":["a":[1, 2], b:[true, false]]
  * ])
  */
------------

As you can see the array notation is borrowed from JSON and arrays can be nested 
arbitrarily. 

The asterisk is ignored by the parser, just like whitespace. That means you can 
do stuff like this:

[source,php]
------------
<?php
/*************
 * @foo(x=1, *
 *      y=2, *
 *      z=3) *
 *************/
------------

The parser also ignores anything before and after an annotation. However once an 
@ is encountered it expects a well-formed annotation. Therefore the following 
can be parsed without problems:

[source,php]
------------
<?php
/**
  * lorem ipsum
  * @annotation lorem
  * ipsum @another.annotation lorem
  * ipsum @and.another(foo="bar", bar=42) lorem
  * ipsum
  */
------------

== The API

The Pia API can be used to retrieve (i.e. parse) annotations on the fly at 
runtime. In order to retrieve the phpdoc which contains the annotations it is 
necessary to use the reflection API. 

[source,php]
------------
<?php
use pia\Registry;

$reflect = new \ReflectionClass('MyAnnotatedClass');
$annotations = Registry::getAnnotations($reflect);
------------

Because reflection is generally slow it is not recommended to use the API in 
this manner if performance matters (note that the annotations will be cached in 
memory by the registry therefore repeating the call won't reparse the phpdoc 
comment).

Fortunately Pia provides a simple alternative that's pretty much as fast as 
possible in PHP userland. Because annotations are compile-time metadata we can 
simply preprocess the annotated codebase and compile the annotations into an 
array. 

For this purpose Pia comes with a small CLI script (bin/pia.php) that you can 
use to process your source code. The script expects two parameters, the first 
one being either a file or a directory while the second parameter specifies the 
output file. The code generated by the script looks like this:

[source,php]
------------
<?php
// generated by Pia
// 2010-06-17T11:36:07+02:00
return array(
'Foo' => array(
new \pia\Annotation('foobar', array (
  'foo' => 'bar',
  'bar' => 'baz',
)),
),
);
------------

You don't need to concern yourself with this detail though. You only need to 
load this file with the Registry using its load method:

[source,php]
------------
<?php
use pia\Registry;
$reg = new Registry();
$reg->load('annotations.php');
------------

Now if you want to lookup the annotations of a specific element without using 
the reflection API you need to know how Pia maps PHP code elements to unique 
array keys. The rules are very simple: the key of a class is simply it's name, 
the key of a method is +<class name>::<method name>+ and the key of a property is 
+<class name>::$<property name>+. The key for a function is its name prefixed by 
the hash symbol (#).

Therefore if we define the following class:

[source,php]
------------
<?php
/**
 * @foobar(foo="bar", bar="baz")
 */
class Foo {
    /**
     * @another.annotation
     */
    private $bar;

    /**
     * @and.another.one
     */ 
    function baz() {
        // code
    }
}
------------

You can lookup the annotations the following way:

[source,php]
------------
<?php
use pia\Registry;
$reg = new Registry;
$reg->load('annotations.php');

$reg->hasAnnotations('Foo');
$reg->hasAnnotations('Foo::baz');
$reg->hasAnnotations('Foo::$bar');
------------

=== Annotation lookup

It is often desired to retrieve elements with a specific annotation therefore 
the Pia registry provides a function called find for this purpose.

Example:

[source,php]
------------
<?php
use pia\Registry;
$reg = new Registry;
$reg->load('annotations.php');
$elements = $reg->find('my.cool.annotation');
------------

Because the registry internally stores the annotations in an array indexed by 
a key based on the annotated element name (see above) a linear search is 
required to extract elements with a specific annotation. To optimize this the 
registry contains a setting called reverseIndexEnabled which, if set to true, 
causes the registry to additionally build a reverse index of the annotations, 
i.e. it puts all annotated elements into an array indexed by annotation name 
thus enabling constant time lookup. 

Example usage:

[source,php]
------------
<?php
use pia\Registry;
$reg = new Registry;
// enable reverse index so we can
// find elements with a specific annotation in
// constant time
$reg->setReverseIndexEnabled(true);
$reg->load('annotations.php');
$elements = $reg->find('my.cool.annotation');
------------

The find function returns an array of appropriate reflection instances for each 
matching element.
