<?php
/* This file is part of Pia.
 *
 * Pia is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * Pia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Pia. If not, see <http://www.gnu.org/licenses/>.
 */

namespace pia\cli;

use pia\Registry;

class CliRunner
{
	private $output;
	private $sources;

	function __construct($output) {
		$this->sources = array();
		$this->output = $output;
	}

	function addSourceFile($file) {
		$hash = md5($file);
		$this->sources[$hash] = $file;
	}

	function parse() {
		$predefined = get_declared_classes();
		foreach ($this->sources as $file) {
			include_once $file;
		}
		$classes = get_declared_classes();
		$userDeclared = array_diff($classes, $predefined);

		$reg = new Registry();
		foreach ($userDeclared as $className) {
			$class = new \ReflectionClass($className);
			if ($class->isInternal()) {
				continue;
			}
			if ($class->getNamespaceName() == ''
				&& $class->getName() == 'Exception') {
				continue;
			}
			$reg->readAnnotations($class);
			$methods = $class->getMethods();
			foreach ($methods as $method) {
				$reg->readAnnotations($method);
			}
			$props = $class->getProperties();
			foreach ($props as $prop) {
				$reg->readAnnotations($prop);
			}
		}

		return $reg;
	}

	function serializeAnnotations(Registry $reg) {
		$date = date('c');
		$this->write("<?php\n// generated by Pia\n// $date\n");
		$this->write("return array(\n");
		foreach ($reg as $key => $annotations) {
			$this->write("\t'$key' => array(\n");
			foreach ($annotations as $annotation) {
				$phpStr = $annotation->toPhpString();
				$this->write("\t\t$phpStr,\n");
			}
			$this->write("\t),\n");
		}
		$this->write(");");
	}

	private function write($str) {
		fwrite($this->output, $str);
	}

	static function parseArgs($argc, $argv) {
		$args = new \stdClass;
		$args->opt = array('d' => array(), 'autoload' => false);
		$remaining = array();
		for ($i = 1; $i < $argc; ++$i) {
			$arg = $argv[$i];
			switch ($arg) {
				case '-d':
					if ($i + 1 == $argc) {
						throw new UsageException(
							"missing value for argument \"$arg\"");
					}
					list($setting, $value) = explode('=', $argv[++$i]);
					$args->opt['d'][$setting] = $value;
					break;
				case '--autoload':
				case '-a':
					$args->opt['autoload'] = true;
					break;
				default:
					$remaining[] = $arg;
			}
		}

		if (count($remaining) < 2) {
			throw new UsageException("missing input and output arguments");
		}

		list($args->input, $args->output) = $remaining;
		return $args;
	}

	static function validateArgs(\stdClass $args) {
		// we return a new object which mirrors the
		// input arguments where they are "converted"
		// to php types
		$processed = new \stdClass;
		$processed->output = null;
		$processed->opt = $args->opt;
		// validate output
		if ($args->output == '-') {
			// we allow "-" to specify stdout as output
			$processed->output = STDOUT;
		}
		else {
			// verify that we can write the output file
			$handle = @fopen($args->output, 'w');
			if (!$handle) {
				throw new UsageException("output file \"$args->output\" cannot be written");
			}
			$processed->output = $handle;
		}
		if (is_dir($args->input)) {
			$iter = new \RecursiveIteratorIterator(
				new \RecursiveDirectoryIterator($args->input));
			$files = new \RegexIterator($iter, '#\.php$#',
				\RecursiveRegexIterator::MATCH);
			$processed->input = $files;
		}
		else if (is_file($args->input)) {
			$processed->input[] = new \SplFileInfo($args->input);
		}
		else {
			throw new UsageException("cannot read input file/directory \"$args->input\"");
		}

		return $processed;
	}

	static function main($argc, $argv) {
		try {
			$args = self::validateArgs(self::parseArgs($argc, $argv));
			if ($args->opt['autoload']) {
				spl_autoload_register();
			}
			foreach ($args->opt['d'] as $setting => $value) {
				ini_set($setting, $value);
			}
			set_include_path(get_include_path() . PATH_SEPARATOR .
				dirname(__FILE__) . '/../..');
			$runner = new self($args->output);
			foreach ($args->input as $file) {
				$runner->addSourceFile($file->getRealPath());
			}
			$annotations = $runner->parse();
			$runner->serializeAnnotations($annotations);
			fclose($args->output);
		}
		// TODO optional stacktrace
		catch (UsageException $e) {
			echo 'Usage Error: ', $e->getMessage(), PHP_EOL;
			echo PHP_EOL, self::getUsage();
			exit(1);
		}
		catch (Exception $e) {
			echo 'Unknown Error: ', $e->getMessage(), PHP_EOL;
			exit(9);
		}
	}

	static function getUsage() {
		return <<<USAGE
SYNOPSIS
pia [OPTIONS] <INPUT> <OUTPUT>

Examples
pia annotated.php annotations.php
pia my-source-folder -
pia -d include_path=src --autoload source/folder output.php

OPTIONS
-d <setting>=<value>  set a php ini setting, e.g. include_path=source/folder
-a --autoload         enable the autoloader

USAGE;
	}
}
